This library allows you to infer types in parsed code **without** type resolution and perform some elementary transformations on inferred types.

While it's fundamentally incorrect to assume types in parsed code, there are use cases where `Result` and `Option` types need to be transformed in some way under the assumption that local scope isn't poluted with weird import aliases and unconventionally named items.

If you end up needing to transform `Result`, you'll have to pretty much re-implement parts of this library yourself and that can be cumbersome.

This library is intended to be used where you can uphold guarantees abount the processed code. Its functionality shouldn't be exposed through macros intended for public consumption unless you're very clear about imposed formatting and import restrictions on the processed code as it might end up confusing dependees with badly generated code.

# Stability

API of all versions prior to `0.1.0` is considered unstable and will likely change. Make sure to pin your dependencies to a patch if you want to avoid surprises.

Versions prior to `1.0.0` are not production ready and use them at your own discretion.

## Completeness

This library will never be feature complete and "do the best it can". It will however try to avoid returning invalid results as much as possible and those are considered bugs.

# Future plans

`Unknown` type can't ever be fully removed from results because of the limited scope of macros, at least until [`proc_macro_span`](https://github.com/rust-lang/rust/issues/54725) gets stable with [`Span::source_file`](https://doc.rust-lang.org/proc_macro/struct.SourceFile.html) (and maybe not even then).

Many scoped items can be at least partially resolved but currently aren't because I personally don't need it. For instance, all identifiers currently return `Unknown` even though they might be defined in the same scope.

A final version of this macro would return types inferred through **deeper block expression traversal**. `proc_macro_span` will remove the danger of wrong assumptions due to import aliases as those could be handled well to some degree (i.e. if they're not generated by another macro).

Additionally, support for **manually specifying some function return types** is required to make this macro a lot more usable. That would also bring about support for caching results so later calls don't need to traverse the AST again.

Lastly, some **parts of the code should be generated from the standard library** (such as `consts` module). As this is currently an intermediate crate I need for something else I didn't put in the required effort to do so yet (write a build script).

## License

This project is licensed under [Zlib](./LICENSE_ZLIB), [MIT](./LICENSE_MIT), or
[Apache-2.0](./LICENSE_APACHE) license, choose whichever suits you most.
